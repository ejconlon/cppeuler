/*
 * The sequence of triangle numbers is generated by adding the natural numbers. So the 7th triangle number would be 1 + 2 + 3 + 4 + 5 + 6 + 7 = 28. The first ten terms would be:
 *
 * 1, 3, 6, 10, 15, 21, 28, 36, 45, 55, ...
 *
 * Let us list the factors of the first seven triangle numbers:
 *
 *  1: 1
 *   3: 1,3
 *    6: 1,2,3,6
 *    10: 1,2,5,10
 *    15: 1,3,5,15
 *    21: 1,3,7,21
 *    28: 1,2,4,7,14,28
 *    We can see that 28 is the first triangle number to have over five divisors.
 *
 *    What is the value of the first triangle number to have over five hundred divisors?
 *
 *
 *    Answer:
 *    76576500
 */

#include <iostream>
#include <vector>
#include <map>
#include <cmath>

void fill_prime_factors(long n, std::vector<long>& primes, std::map<long, long>& map);
void fill_primes_lt(long limit, std::vector<long>& primes);
template <typename K, typename V>
V default_find(K key, V defaultValue, std::map<K, V>& map);
long ndivisors(long n, std::vector<long>& primes);

int main() {
    std::vector<long> primes;    

    long divlim = 500;

    long tx = 1;
    long ti = 2;
    for (long nd=-1; nd < divlim; ti++) {
        tx += ti;
        nd = ndivisors(tx, primes);
        //std::cout << ti << " " << tx << " " << nd << std::endl;
    }


    std::cout << tx << std::endl;

    return 0; 
}

void fill_primes_lt(long limit, std::vector<long>& primes) {
    long cand = 5;
    if (primes.size() == 0) {
        primes.push_back(2);
        primes.push_back(3);
    } else {
        cand = primes.back()+2;
    }

    while (cand < limit) {
        bool prime = true;
        long end = sqrt(cand) + 1;
        for (std::vector<long>::const_iterator pi = primes.begin(); pi != primes.end(); pi++) {
            if (cand % *pi == 0)  {
                prime = false;
                break;
            } else if (*pi > end) {
                break;
            }
        }
        if (prime) {
            primes.push_back(cand);
        }
        cand+=2;
    }
}

void fill_prime_factors(long n, std::vector<long>& primes, std::map<long, long>& map){

    fill_primes_lt(n+1, primes);

    while (true) {
        if (n == 1) break; 
        for (std::vector<long>::const_iterator pi = primes.begin(); pi != primes.end(); pi++) {
            if (n % *pi == 0) {
                n /= *pi;
                map[*pi] = default_find<long, long>(*pi, 0, map) + 1; 
                break;
            }
        }
    }
}

template <typename K, typename V>
V default_find(K key, V defaultValue, std::map<K, V>& map){
    if (map.count(key) == 0) {
        return defaultValue;
    } else {
        return map.find(key)->second;
    }
}

long ndivisors(long n, std::vector<long>& primes){
    std::map<long, long> map;
    fill_prime_factors(n, primes, map);
    long nd = 1;
    for (std::map<long, long>::const_iterator it = map.begin(); it != map.end(); it++) {
        nd *= (it->second+1);
    }
    return nd; 
}

